# Sketch Grammar for Polish, using the tagset of the IPI PAN Corpus of Polish (KIPI/IPIC; korpus.pl).
# Version 1.1.
#
# This grammar is quite crude but so seem the grammars for Czech, Slovenian and Russian.
# If they are useful, this one should also be.
#
# The Polish corpus seems to be lacking information about grammatical case (also number and gender)
# on the token level. To check the value of case, one must write crytpic regexen. Hence the need to
# enumerate all possible values of case to account for case agreements. Such agreements have been
# generated by the following script:
# echo "# BEGIN"; for cas in nom gen dat acc inst loc voc; do sed "s/CAS/$cas/g" < query; done; echo "# END"
#
# NOTE: only case agreements are checked, there are no assertions for obligatory number and gender
# agreements. This is because there are 70 combinations of possible values of nmb,gnd,case. Hence,
# each rule that involves such an agreement would have to be expanded into 70 queries. This can't
# be handled better unless nmb, gnd and case are encoded as token attributes in the corpus.
#
# Tagset wordclass summary (for details, see korpus.pl):
# adj/noun/pers.pron:      pact ppas adj adja adjp subst   ger depr ppron12 ppron3 siebie 
# adverbial:            adv pant pcon 
# odd verb classes:     pred winien aglt bedzie 
# regular verb classes: fin praet imps impt inf 
# other stuff:          prep qub num interp conj ign

*STRUCTLIMIT s
*DEFAULTATTR tag
*WSPOSLIST ",adjective,-j,noun,-n,verb,-v"
#number of prepositions with a ws relation is very limited, sth like 1%, however, the most frequent prep. are covered

# macro defs

divert(-1)
define(`VERB', `[(tag="praet.*"|tag="inf.*"|tag="im.*"|tag="fin.*") & !(lemma="być"|lemma="zostać"|lemma="chcieć"|lemma="musieć"|lemma="móc")]')
define(`V_be', `[lemma="być" & !(tag="aglt.*")]')

define(`NOUN', `[tag="subst.*"|tag="ger.*"|tag="depr.*"]')
define(`N_LIKE', `[tag="subst.*"|tag="ppron.*"|tag="ger.*"|tag="depr.*"|tag="ppron.*"]')

# parametrised by case
define(`N', `[tag="subst:..:$1:.*"|tag="ger:..:$1:.*"|tag="depr:..:$1:.*"]')
define(`ADJ', `[tag="adj:..:$1:.*"|tag="pact:..:$1:.*"]')
define(`ADJPAS', `[tag="adj:..:$1:.*"|tag="pact:..:$1:.*"|tag="ppas:..:$1:.*"]')
# indecl
define(`ADVERB', `[tag="adv.*"|tag="qub"]')
define(`CONJ', `[word=","|word="i"|word="lub"|word="albo"]')

# material that may intervene btw verb and noun, probably without destroying the relation
# namely, adj, adv, particle, verbal ending
define(`NV_SAFE', `[tag="ad.*"|tag="qub.*"|tag="num.*"|tag="aglt.*"|tag="bedzie.*"]')

# as above, but parametrised -- allowing nouns with case other than the given
define(`NV_SAFE_OTHER', `[tag="bedzie.*"|tag="ad.*"|tag="qub.*"|tag="num.*"|tag="aglt.*"|tag="subst:..:(?!$1).*"|tag="ger:..:(?!$1).*"|tag="ppron.*:..:(?!$1).*"|tag="depr:..:(?!$1).*"]')

divert

############

=coord
*SYMMETRIC
*UNIMAP and/or
# coord of nouns, agreed on case (any number, gender)
# quite crude, won't handle any modifiers (do we want adj-noun sequences as noun coordinations?)
# X i/lub/albo AND ani X, ani Y (agreed on case)
# TEMPLATE:
## 1:N(CAS) CONJ (N(CAS) CONJ){0,5} 2:N(CAS)
## [word = "(?i)ani"] 1:N(CAS) [word = ","]? [word = "ani"] 2:N(CAS)
# BEGIN
1:N(nom) CONJ (N(nom) CONJ){0,5} 2:N(nom)
[word = "(?i)ani"] 1:N(nom) [word = ","]? [word = "ani"] 2:N(nom)
1:N(gen) CONJ (N(gen) CONJ){0,5} 2:N(gen)
[word = "(?i)ani"] 1:N(gen) [word = ","]? [word = "ani"] 2:N(gen)
1:N(dat) CONJ (N(dat) CONJ){0,5} 2:N(dat)
[word = "(?i)ani"] 1:N(dat) [word = ","]? [word = "ani"] 2:N(dat)
1:N(acc) CONJ (N(acc) CONJ){0,5} 2:N(acc)
[word = "(?i)ani"] 1:N(acc) [word = ","]? [word = "ani"] 2:N(acc)
1:N(inst) CONJ (N(inst) CONJ){0,5} 2:N(inst)
[word = "(?i)ani"] 1:N(inst) [word = ","]? [word = "ani"] 2:N(inst)
1:N(loc) CONJ (N(loc) CONJ){0,5} 2:N(loc)
[word = "(?i)ani"] 1:N(loc) [word = ","]? [word = "ani"] 2:N(loc)
1:N(voc) CONJ (N(voc) CONJ){0,5} 2:N(voc)
[word = "(?i)ani"] 1:N(voc) [word = ","]? [word = "ani"] 2:N(voc)
# END

*DUAL
=a_modifier/modifies
*UNIMAP modifier/modifies
# is modified / is a modifier
# NOTE: only case agr is checked, no assertion for nmb & gnd.
# TEMPLATE:
## 1:N(CAS) 2:ADJPAS(CAS)
## 2:ADJPAS(CAS) (CONJ ADJPAS(CAS)){0,4} 1:N(CAS)
# BEGIN
1:N(nom) 2:ADJPAS(nom)
2:ADJPAS(nom) (CONJ ADJPAS(nom)){0,4} 1:N(nom)
1:N(gen) 2:ADJPAS(gen)
2:ADJPAS(gen) (CONJ ADJPAS(gen)){0,4} 1:N(gen)
1:N(dat) 2:ADJPAS(dat)
2:ADJPAS(dat) (CONJ ADJPAS(dat)){0,4} 1:N(dat)
1:N(acc) 2:ADJPAS(acc)
2:ADJPAS(acc) (CONJ ADJPAS(acc)){0,4} 1:N(acc)
1:N(inst) 2:ADJPAS(inst)
2:ADJPAS(inst) (CONJ ADJPAS(inst)){0,4} 1:N(inst)
1:N(loc) 2:ADJPAS(loc)
2:ADJPAS(loc) (CONJ ADJPAS(loc)){0,4} 1:N(loc)
1:N(voc) 2:ADJPAS(voc)
2:ADJPAS(voc) (CONJ ADJPAS(voc)){0,4} 1:N(voc)
# END

=prec_prep
# prep+mod*+noun
# TEMPLATE: 2: [tag="prep:CAS.*"] [tag="ad.*"|tag="qub.*"|tag="num.*"|tag="ppron3:..:gen.*"]{0,4} 1:N(CAS)
# BEGIN
2: [tag="prep:nom.*"] [tag="ad.*"|tag="qub.*"|tag="num.*"|tag="ppron3:..:gen.*"]{0,4} 1:N(nom)
2: [tag="prep:gen.*"] [tag="ad.*"|tag="qub.*"|tag="num.*"|tag="ppron3:..:gen.*"]{0,4} 1:N(gen)
2: [tag="prep:dat.*"] [tag="ad.*"|tag="qub.*"|tag="num.*"|tag="ppron3:..:gen.*"]{0,4} 1:N(dat)
2: [tag="prep:acc.*"] [tag="ad.*"|tag="qub.*"|tag="num.*"|tag="ppron3:..:gen.*"]{0,4} 1:N(acc)
2: [tag="prep:inst.*"] [tag="ad.*"|tag="qub.*"|tag="num.*"|tag="ppron3:..:gen.*"]{0,4} 1:N(inst)
2: [tag="prep:loc.*"] [tag="ad.*"|tag="qub.*"|tag="num.*"|tag="ppron3:..:gen.*"]{0,4} 1:N(loc)
2: [tag="prep:voc.*"] [tag="ad.*"|tag="qub.*"|tag="num.*"|tag="ppron3:..:gen.*"]{0,4} 1:N(voc)
# END

### primitive verbal relations

# verb followed by a preposition (quite crude)
=post_prep
	1:VERB [tag="aglt.*"|tag="qub.*"|tag="adv.*"]{0,4} 2:"prep.*"

=post_inf
# is it really useful? ripped off Slovenian & Czech one
	1:[] 2:[tag="inf:.*"]

# the two below are awfully naive and will generate lots of rubbish
# (inspired by Slovenian and Czech relations)
=prec_verb
*UNIMAP object_of
	2:VERB NV_SAFE{0,5} 1:N_LIKE

=post_verb
	1:N_LIKE NV_SAFE{0,5} 2:VERB

### now the real verb/noun relations

*DUAL
=is_subj/has_subj
*UNIMAP subject_of/subject
	1:N(nom) NV_SAFE{0,5} 2:[(tag="praet.*"|tag="fin.*") & !(lemma="być"|lemma="zostać"|lemma="chcieć"|lemma="musieć"|lemma="móc")]
	2:[(tag="praet.*"|tag="fin.*") & !(lemma="być"|lemma="zostać"|lemma="chcieć"|lemma="musieć"|lemma="móc")] NV_SAFE{0,5} 1:N(nom)


*DUAL
=być_adj/subj_być
*UNIMAP adj_subject_of/adj_subject
	1:N(nom) ADVERB{0,3} V_be ADVERB{0,3} 2:ADJ(nom)
	2:ADJ(nom) ADVERB{0,3} V_be ADVERB{0,3} 1:N(nom)

*DUAL
=passive/subj_of_passive
*UNIMAP passive
	1:N(nom) ADVERB{0,3} V_be ADVERB{0,3} 2:[tag="ppas:..:nom:.*"]

*DUAL
=gen_modifier/gen_modifies
*UNIMAP modifier/modifies
	1:NOUN adjpas_gen{0,4} 2:N(gen)
# NOTE: the reverse order is not handled as it's pretty rare and likely to
# cause false positives (especially for gen-gen combinations).
# If desired, use the following template:
# 1:N(gen) [tag="adj:..:CAS:.*"|tag="ppas:..:CAS:.*"|tag="pact:..:CAS:.*"]{0,4} noun_CAS

# Unlike the Czech grammar, the one below allows for indirect objects
# separated from the verb by another nouns; this is a likely cause for
# false positives, especially on mistagged intput

*DUAL
=is_obj2/has_obj2
*UNIMAP object/object_of
# gen
	2:VERB NV_SAFE_OTHER(gen) 1:N(gen)
	1:N(gen) NV_SAFE_OTHER(gen) 2:VERB

*DUAL
=is_obj3/has_obj3
*UNIMAP object/object_of
# dat, also allowing for non-dat noun-like material
	2:VERB NV_SAFE_OTHER(dat){0,5} 1:N(dat)
	1:N(dat) NV_SAFE_OTHER{dat}{0,5} 2:VERB

*DUAL
=is_obj4/has_obj4
*UNIMAP object/object_of
# acc
	2:VERB NV_SAFE_OTHER(acc) 1:N(acc)
	1:N(acc) NV_SAFE_OTHER(acc) 2:VERB

*DUAL
=is_obj7/has_obj7
*UNIMAP object/object_of
	2:VERB NV_SAFE_OTHER(inst) 1:N(inst)
	1:N(inst) NV_SAFE_OTHER(inst) 2:VERB

### now the ternary relations with prepositions (noun|verb prep mod* noun)

*TRINARY
=post_%(3.lemma)
*UNIMAP pp_%(3.lemma)
# TEMPLATE:
# 1:NOUN 3:[tag="prep:CAS.*"] NV_SAFE{0,5} 2:N(CAS)
# 1:VERB 3:[tag="prep:CAS.*"] NV_SAFE{0,5} 2:N(CAS)
# BEGIN
1:NOUN 3:[tag="prep:nom.*"] NV_SAFE{0,5} 2:N(nom)
1:VERB 3:[tag="prep:nom.*"] NV_SAFE{0,5} 2:N(nom)
1:NOUN 3:[tag="prep:gen.*"] NV_SAFE{0,5} 2:N(gen)
1:VERB 3:[tag="prep:gen.*"] NV_SAFE{0,5} 2:N(gen)
1:NOUN 3:[tag="prep:dat.*"] NV_SAFE{0,5} 2:N(dat)
1:VERB 3:[tag="prep:dat.*"] NV_SAFE{0,5} 2:N(dat)
1:NOUN 3:[tag="prep:acc.*"] NV_SAFE{0,5} 2:N(acc)
1:VERB 3:[tag="prep:acc.*"] NV_SAFE{0,5} 2:N(acc)
1:NOUN 3:[tag="prep:inst.*"] NV_SAFE{0,5} 2:N(inst)
1:VERB 3:[tag="prep:inst.*"] NV_SAFE{0,5} 2:N(inst)
1:NOUN 3:[tag="prep:loc.*"] NV_SAFE{0,5} 2:N(loc)
1:VERB 3:[tag="prep:loc.*"] NV_SAFE{0,5} 2:N(loc)
1:NOUN 3:[tag="prep:voc.*"] NV_SAFE{0,5} 2:N(voc)
1:VERB 3:[tag="prep:voc.*"] NV_SAFE{0,5} 2:N(voc)
# END

*TRINARY
=prec_%(3.lemma)
*UNIMAP pp_obj_%(3.lemma)
# TEMPLATE:
# 2:NOUN 3:[tag="prep:CAS.*"] NV_SAFE{0,5} 1:N(CAS)
# 2:VERB 3:[tag="prep:CAS.*"] NV_SAFE{0,5} 1:N(CAS)
# BEGIN
2:NOUN 3:[tag="prep:nom.*"] NV_SAFE{0,5} 1:N(nom)
2:VERB 3:[tag="prep:nom.*"] NV_SAFE{0,5} 1:N(nom)
2:NOUN 3:[tag="prep:gen.*"] NV_SAFE{0,5} 1:N(gen)
2:VERB 3:[tag="prep:gen.*"] NV_SAFE{0,5} 1:N(gen)
2:NOUN 3:[tag="prep:dat.*"] NV_SAFE{0,5} 1:N(dat)
2:VERB 3:[tag="prep:dat.*"] NV_SAFE{0,5} 1:N(dat)
2:NOUN 3:[tag="prep:acc.*"] NV_SAFE{0,5} 1:N(acc)
2:VERB 3:[tag="prep:acc.*"] NV_SAFE{0,5} 1:N(acc)
2:NOUN 3:[tag="prep:inst.*"] NV_SAFE{0,5} 1:N(inst)
2:VERB 3:[tag="prep:inst.*"] NV_SAFE{0,5} 1:N(inst)
2:NOUN 3:[tag="prep:loc.*"] NV_SAFE{0,5} 1:N(loc)
2:VERB 3:[tag="prep:loc.*"] NV_SAFE{0,5} 1:N(loc)
2:NOUN 3:[tag="prep:voc.*"] NV_SAFE{0,5} 1:N(voc)
2:VERB 3:[tag="prep:voc.*"] NV_SAFE{0,5} 1:N(voc)
# END
